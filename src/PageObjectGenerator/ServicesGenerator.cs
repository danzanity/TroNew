using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace PageObjectSourceGenerator
{
	[Generator]
	public class ServicesGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext context)
		{
			context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
		}

		public void Execute(GeneratorExecutionContext context)
		{
			if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
			{
				return;
			}

			var source = new StringBuilder(@"using Microsoft.Extensions.DependencyInjection;

namespace PageObjectSourceGenerator
{
	public static class Services
	{
		public static IServiceCollection AddAutoGeneratedPageObjects(this IServiceCollection services) => services");

			foreach (var type in receiver.Types)
			{
				source.Append($"{Environment.NewLine}\t\t\t.AddTransient<{type}>()");
			}

			source.Append(@";
	}
}");
			context.AddSource("Services.generated.cs", SourceText.From(source.ToString(), Encoding.UTF8));
		}

		private class SyntaxReceiver : ISyntaxContextReceiver
		{
			public IList<string> Types { get; } = new List<string>();

			public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
			{
				if (!(context.Node is ClassDeclarationSyntax cds))
				{
					return;
				}

				// Get the symbol being declared by the class, and keep it if it ends with `Page`
				var clsSymbol = context.SemanticModel.GetDeclaredSymbol(cds) as INamedTypeSymbol;
				var name = clsSymbol.ToString();
				if (name.EndsWith("Page"))
				{
					Types.Add(name);
				}
			}
		}
	}
}